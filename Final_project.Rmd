---
title: "Untitled"
author: "Jaden Anderson"
date: "May 1st, 2018"
output:
  html_document:
    df_print: paged
  pdf_document:
    fig_caption: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
```
# Introduction

Gram negative bacteria have a unique arrangement of membranes that help them persist in their enviornment: an outer and inner membrane. On these membranes exist a variety of proteins and structures that have a range of functions that the bacteria utilize[@Remmert2010]. Outer membrane proteins are used to interact with their extracellular enviornment that have a diverse array of functions like import and export of substances, cell adhesion, proteolysis, membrane protein insertion, and more. Even though proteins on the outer membrane have a variety of functions, surprisingly the secondary structure of these proteins (i.e. the structure of what the proteins look like) are very similar[@Franklin, @article]. While these secondary structures are highly similar, their sequence composition (or similarity) is highly variable which makes studying their evolution very difficult. An evolutionary analysis based on HMM profiles was carried out and distinguished roughly 8 unique groups of outer membrane beta barrels (OMBBs) [@Franklin]. ![Figure 1: his figure is taken from "The Complex Evolution of Outer Membrane Proteins". This figure illustrated the evolutionary relationships and connectedness of the OMBBs. A) The 8 groups broken up into Prototypical Barrels, Lysins, Efflux Pumps, Adhesins, Assembly proteins, Fim/Usher proteins, and LptD proteins. B) A structural representation of the conserved structure of the proteins from each group. ](groups_ombbs.png) The folding patterns of the OMBBs is controlled by the assembly group of proteins which consist of a small group of proteins as seen from Figure 1. The most notable assembly complex in gram negative bacteria is the beta barrel assembly complex or BamA. It is responsible for folding the majority of OMBBs into the outer membrane however its evolutionary relationship with the other OMBBs its responsible for is not well understood. Given it's important role in the folding process of OMBBs it is surprising that BamA or the assembly proteins have little to no connectedness through HMM profiles which can be used as a measure of evolutionary relationships. In this study, I will perform a sequence based analysis of BamA and the current 130 structurally characterized OMBBs. My hypothesis is that BamA sequences in different species will be highly connected or overlap with critically important beta barrels from that same species of BamA, which might give insight onto the folding preferences of the beta barrel assembly complex.

# Methods

_Basic Local Alignment Search Tool or BLAST_

BLASTing protein sequences is a fairly standard practive when trying to determine relationships between different proteins. The BLASTing algorithm that I used is PSIBlast which is based off the NCBI blastp algorithm. Normal BLAST (or blastp) is a sequence similarity search method which identifies like protein sequences based off given thresholds like homology or sequence similiarty. PSIBLAST is an iterative tool that builds protein sequence profiles from blastp results in order to refine search space and produce higher scoring alignments. I PSIblasted BamA along with all 130 structurally characterized OMBBs in order to generate multiple sequence alignments. In order to make sure I was pulling similar sequences, I used a false positive rate or evalue of 10^-50. 

The parent sequence, or original sequence, used to PSIBLAST similar proteins were pulled from the IDB. A PDB identifier is a 4 digit combination of numbers and letters with an optional chain identifier (_letter). I grabbed all 130 PDB files from the RSCB PDB webserver. 

_Determining Overlapping Species_

Once I've obtained the PSIBLASTed sequences I will determine the number of overlapping sequences of BamA with a client protein (one that BamA is responsible for folding). To do this, I will exploit the format of FASTA files and use regular expression to grab unique species identifiers. Once I have grabbed those species from BamA, I will compare that list to each of the species that resulted from the PSIBLAST alignments for each client protein. This process can be found in the python chunk get_overlapping_sp of this RMD. In order for this script to be sucessful, I must use the reformat_MSA python chunk to reformat the alignments generated from the PSIBLASTed results. This is done to make the parsing quicker. 

_Testing Formats_

In order to ensure that the data that I've grabbed from the NCBI webserver from PSIBLAST is in the proper formats, I will be loading the Rpackage that I wrote for the last project in order to use the format and protein unit tests on my sequences. I will not need to use the same_size unit test, as this analysis does not care about the size of the proteins in the multiple sequence alignment. 

_Modularity_

It is critically important that a script that works on one file works on all 130 OMBBs fasta files that I have in this directory. In order to accomplish that, all scripts written in this project will be modular. Sciprts were originally written in python and imported to RMD using the Knitr capabilities.

```{python reformat_MSA, echo = FALSE}
import re
import os

#Function that reformats the fasta files given from the PSIBLAST result into identifier and sequence on serperate lines
def reformat_dir(filename):
    #Open the file passed through and write a reformated version of it with the same PDB identifier
    with open(filename, "r") as f, open(filename +"_reformated.txt", "w+") as w:
        seq = ""
        begin_line = ""
        
        #For each line in the open file
        for line in f:	
            #Identify if we're on an ID line
            if ">" in line:
               #Save that ID line
               begin_line = line
               
               #If we also have a sequence, then print to the reformated file
               if(len(seq) != 0):
                   w.write(begin_line)
                   w.write(seq + "\n")
                   seq = ""			
            #Grab the sequence and strip any excess characters like \ns or whitespace
            else:
               seq += line.strip()
    return()

#Grab the current working directory that is open if it has the 1T16.fasta file in it
dir_name = str(os.path.dirname(os.path.realpath("1T16.fasta")))


#Loop through that directory and reformat only the *.fasta files
for f in os.listdir(dir_name):
  if f.endswith(".fasta"):
    reformat_dir(f)
```

```{python get_overlapping_sp, echo = FALSE}

import re
import os

bama = "reformat_total_bama_blastp_seqs.txt"

def loop_dir(filename):
  species = []
  i = 0
  with open(bama) as inFile:
    for line in inFile:
      line = line.strip()
      if line.startswith('>'):
        regex = re.compile('(\[(.+?)\].*)')
        
        try: 
          matches = regex.search(line).group(1)[1:-1]
        except AttributeError:
          matches = None
        if matches is not None:
          species.append(matches)
          
  unique_sp = list(set(species))
  seq = ""
  count_overlap = 0
  
  with open(filename) as inFile:
    for line in inFile:
      if line.startswith('>'):
        name_line = line
        regex = re.compile('(\[(.+?)\].*)')
        
        try: 
          to_match = regex.search(line).group(1)[1:-1]
        except AttributeError:
          to_match = None
        if to_match is not None:
          for i in unique_sp:
            if i == to_match:
              count_overlap += 1
              unique_sp.remove(i)

  return count_overlap

dir_name = str(os.path.dirname(os.path.realpath("1T16.fasta")))

counts = 0
with open("overlapping_sp_of_bama.txt", "w+") as outFile:
  for f in os.listdir(dir_name):
    if f.endswith(".fasta_reformated.txt"):
      counts = str(loop_dir(f))
      outFile.write(f + "\t" + counts + "\n")

```


```{r plot_seq_counts, echo = FALSE}

seq_counts <- read.table("overlapping_sp_of_bama.txt")
seq_counts <- seq_counts[order(seq_counts$V2, decreasing = TRUE),]
seq_counts <- seq_counts[seq_counts$V2 > 500,]
named <- as.vector(seq_counts[[1]])
data <- as.vector(seq_counts[[2]])
names(data) <- c('4K3B', '4K3C','5IVA','4Q35','5IXM','1EK9','5FOK','5FP1','4N75','4C00','5AZP','4MT0','3D5K','2GSK','5AZS','4K7R','3QLB','2HDI','4CU4','1YC9','4RDR','5FR8','3EFM','5FP2','1FEP','2IAH','1XKW','1T16','5WQ8','1KMO','5WQ7','2F1V')
barplot(data, las = 2, cex.names = 0.8)
```